#!/usr/bin/env python3
"""
booklookup: tiny CLI tool for quick lookups while reading

Features:
- Definitions of words (via free dictionary API)
- Short summaries of people/places/concepts (via Wikipedia summary API)
- Text-only terminal output
"""

import argparse
import json
import sys
import urllib.parse
import urllib.request


DICTIONARY_API_URL = "https://api.dictionaryapi.dev/api/v2/entries/en/{word}"
WIKIPEDIA_SUMMARY_URL = "https://en.wikipedia.org/api/rest_v1/page/summary/{title}"


def http_get(url, timeout=5):
    req = urllib.request.Request(
        url,
        headers={
            "User-Agent": "booklookup-cli/1.0 (https://example.com)"
        },
    )
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        if resp.status != 200:
            raise RuntimeError(f"HTTP {resp.status}")
        return resp.read().decode("utf-8")


def lookup_dictionary(word):
    url = DICTIONARY_API_URL.format(word=urllib.parse.quote(word))
    try:
        data = http_get(url)
    except Exception as e:
        raise LookupError(f"Dictionary lookup failed: {e}") from e

    try:
        payload = json.loads(data)
    except json.JSONDecodeError as e:
        raise LookupError(f"Dictionary response could not be parsed: {e}") from e

    if isinstance(payload, dict) and payload.get("title") == "No Definitions Found":
        raise LookupError("No dictionary definitions found.")

    if not isinstance(payload, list) or not payload:
        raise LookupError("Unexpected dictionary response format.")

    entry = payload[0]
    meanings = entry.get("meanings", [])
    if not meanings:
        raise LookupError("No meanings in dictionary entry.")

    lines = []

    word_text = entry.get("word", word)
    phonetics = entry.get("phonetics") or []
    phonetic_str = ""
    for ph in phonetics:
        text = ph.get("text")
        if text:
            phonetic_str = text
            break

    header = word_text
    if phonetic_str:
        header += f" {phonetic_str}"
    lines.append(header)

    for meaning in meanings:
        pos = meaning.get("partOfSpeech", "")
        if pos:
            lines.append(f"({pos})")
        definitions = meaning.get("definitions", [])
        for i, d in enumerate(definitions, start=1):
            definition_text = d.get("definition", "").strip()
            if not definition_text:
                continue
            lines.append(f"{i}. {definition_text}")
            example = d.get("example")
            if example:
                lines.append(f"   e.g. {example.strip()}")
        # Only show the first meaning block for brevity
        break

    if len(lines) == 1:
        raise LookupError("Dictionary entry contained no usable text.")

    return "\n".join(lines)


def truncate_sentences(text, max_sentences):
    if max_sentences <= 0:
        return text

    # Simple sentence split. Not perfect, but good enough for quick reading.
    parts = text.replace("\n", " ").split(". ")
    if len(parts) <= max_sentences:
        return text.strip()

    selected = parts[:max_sentences]
    truncated = ". ".join(selected).strip()
    if not truncated.endswith("."):
        truncated += "."
    return truncated


def lookup_wikipedia(title, max_sentences=3):
    url = WIKIPEDIA_SUMMARY_URL.format(title=urllib.parse.quote(title))
    try:
        data = http_get(url)
    except Exception as e:
        raise LookupError(f"Wikipedia lookup failed: {e}") from e

    try:
        payload = json.loads(data)
    except json.JSONDecodeError as e:
        raise LookupError(f"Wikipedia response could not be parsed: {e}") from e

    if payload.get("type") == "https://mediawiki.org/wiki/HyperSwitch/errors/not_found":
        raise LookupError("Wikipedia page not found.")

    title_out = payload.get("title", title)
    extract = payload.get("extract")
    if not extract:
        raise LookupError("Wikipedia page had no summary text.")

    extract_short = truncate_sentences(extract, max_sentences)

    lines = [
        title_out,
        extract_short,
        "[Source: Wikipedia]",
    ]
    return "\n".join(lines)


def main(argv=None):
    parser = argparse.ArgumentParser(
        description="Quick CLI lookups for words, people, places (dictionary + Wikipedia).",
        epilog="Examples:\n"
               "  booklookup perspicacious\n"
               "  booklookup --mode wiki \"Ada Lovelace\"\n"
               "  booklookup --mode auto \"Battle of Hastings\"",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "query",
        nargs="+",
        help="Word or name to look up (e.g. 'perspicacious', 'Ada Lovelace').",
    )
    parser.add_argument(
        "-m",
        "--mode",
        choices=["auto", "dict", "wiki"],
        default="auto",
        help="Lookup mode: 'dict' (dictionary only), 'wiki' (Wikipedia only), "
             "'auto' (try dictionary then Wikipedia). Default: auto.",
    )
    parser.add_argument(
        "-s",
        "--sentences",
        type=int,
        default=3,
        help="Max sentences for Wikipedia summary (default: 3). Ignored for dictionary lookups.",
    )

    args = parser.parse_args(argv)
    query_text = " ".join(args.query).strip()

    if not query_text:
        parser.error("Empty query.")

    mode = args.mode
    output = None
    errors = []

    if mode in ("auto", "dict"):
        try:
            output = lookup_dictionary(query_text)
        except LookupError as e:
            errors.append(str(e))
            if mode == "dict":
                # dictionary-only mode: stop here
                pass

    if output is None and mode in ("auto", "wiki"):
        try:
            output = lookup_wikipedia(query_text, max_sentences=args.sentences)
        except LookupError as e:
            errors.append(str(e))

    if output is None:
        sys.stderr.write("No result found.\n")
        if errors:
            for err in errors:
                sys.stderr.write(f"- {err}\n")
        sys.exit(1)

    print(output)


if __name__ == "__main__":
    main()
